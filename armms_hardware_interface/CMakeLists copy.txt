cmake_minimum_required(VERSION 2.8.3)
project(armms_hardware_interface)
add_compile_options(-std=c++11)

find_package(catkin REQUIRED dynamic_reconfigure COMPONENTS
  roscpp
  rospy
  std_msgs
  controller_manager
  joy
)

# link_directories(${PROJECT_SOURCE_DIR}/lib/${CMAKE_LIBRARY_ARCHITECTURE})

# export library to other packages
catkin_package(
  INCLUDE_DIRS include
  LIBRARIES armms_hardware_interface
  CATKIN_DEPENDS roscpp rospy std_msgs controller_manager
#  DEPENDS system_lib
)

###########
## Build ##
###########

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

#Testers
#add_executable(test_kinova_arm_control src/testers/test_kinova_arm_controller.cpp )
#add_dependencies(test_kinova_arm_control ${PROJECT_NAME}_gencfg)
#add_dependencies(test_kinova_arm_control ${${PROJECT_NAME}_EXPORTED_TARGETS})
#add_executable(test_kinova_arm_vel src/testers/test_kinova_arm_vel.cpp )
#add_executable(test_kinova_arm_car_vel src/testers/test_kinova_arm_car_vel.cpp )

# Nodes
# Note, the headers are shown here so they show up in the project view when using
# Qt Creator. There must be a better way...

# add_library(armms_libkinova
#   src/armms_api.cpp
#   include/armms_hardware_interface/armms_api.h
#   include/kinovadrv/kinovadrv.h
# )

# add_executable(armms_driver_node
  # src/nodes/armms_driver_node.cpp
# )

# add_dependencies(armms_driver_node ${catkin_EXPORTED_TARGETS})
# target_link_libraries(armms_libkinova ${catkin_LIBRARIES} dl)
# target_link_libraries(armms_driver_node ${catkin_LIBRARIES} dl)
# target_link_libraries(armms_driver_node ${catkin_LIBRARIES} armms_libkinova kinovadrv)

add_executable(armms_hardware_interface_node
src/nodes/armms_hardware_interface_node.cpp
src/armms_hardware_interface.cpp
src/armms_api.cpp
src/kinovadrv/kinovadrv.cpp
)
target_link_libraries(armms_hardware_interface_node 
  ${catkin_LIBRARIES} ${Boost_LIBRARIES})
# target_link_libraries(armms_driver_node ${catkin_LIBRARIES} dl)
# target_link_libraries(armms_hardware_interface_node ${catkin_LIBRARIES} armms_libkinova kinovadrv)


############ hl controller
add_executable(hl_controller
  src/hl_controller.cpp  
)
target_link_libraries(hl_controller ${catkin_LIBRARIES})
add_dependencies(hl_controller ${catkin_EXPORTED_TARGETS})

############ device freejoy 
add_executable(device_freejoy
  src/device_freejoy.cpp
)
target_link_libraries(device_freejoy ${catkin_LIBRARIES})
add_dependencies(device_freejoy ${catkin_EXPORTED_TARGETS})

#############
## Install ##
#############

# Copy over Kinova .so binary blobs to /usr/lib
install(FILES
  lib/${CMAKE_LIBRARY_ARCHITECTURE}/libkinovadrv.so
  # lib/${CMAKE_LIBRARY_ARCHITECTURE}/USBCommandLayerUbuntu.so
  # lib/${CMAKE_LIBRARY_ARCHITECTURE}/EthCommLayerUbuntu.so
  # lib/${CMAKE_LIBRARY_ARCHITECTURE}/EthCommandLayerUbuntu.so
  DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
)

install(DIRECTORY include/${PROJECT_NAME}/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
  FILES_MATCHING PATTERN "*.h"
)


## Mark executables and/or libraries for installation
install(TARGETS armms_hardware_interface_node 
# kinova_tf_updater
# kinova_interactive_control
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)

## Mark cpp header files for installation
install(DIRECTORY include/${PROJECT_NAME}/
  DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}
  FILES_MATCHING PATTERN "*.h"
)

## Mark other files for installation (e.g. launch and bag files, etc.)
#  install(FILES
## myfile1
## myfile2
#  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}

#############
## Testing ##
#############

## Add gtest based cpp test target and link libraries
# catkin_add_gtest(${PROJECT_NAME}-test test/test_kinova_driver.cpp)
# if(TARGET ${PROJECT_NAME}-test)
#   target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME})
# endif()

## Add folders to be run by python nosetests
#catkin_add_nosetests(test)
